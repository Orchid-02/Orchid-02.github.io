<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F05%2F16%2F%E2%80%9CC%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E2%80%9D%E5%BC%80%E5%8F%91%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[“C语言题库”开发体会耗时两周（大概），把数据库实训写完了。写篇专栏记录一下实训中遇到的问题 1.前端1.1.TabBarTabBar指的是导航栏控件。一般在小程序进行页面跳转时都是用wx.redirectTo(关闭当前页，跳转指定页)和wx.navigateTo(保留当前页（隐藏），跳转指定页)，但是这两个都不能直接跳转到带有TabBar的页面。如果需要跳转则采用wx.switchTab(只能用于跳转到TabBar页面，并关闭其他非TabBar页面,TabBar之间做切换)。 1.2.页面滑动在做题界面肯定要涉及到如何左右滑动切换题目。虽然老师已经给了“answer_info”，但是仍需要了解具体是怎么实现的。 首先是题号切换。通过采用e.currentTarget注册了监听点击事件的组件，即无论我们进行左滑或者是右滑操作时，这个事件都可以被e.currentTarget监听到，从而进行判断题号的增减。 接着就是页面的切换。在“info.js”中采用的是swiper进行切换。swiper对象本身是通过h5触摸事件触发的swiper对象内部所封装的滑动事件处理函数，通过这个切换处理函数实现的swiper对象的子对象swiper-item所生成的模块的滑动切换效果。 页面滑动主要可能出现疯狂刷屏和巍然不动两个问题。 疯狂刷屏的原因是swiper对象对swiper对象的H5触摸事件:touchstart、touchmove、touchend做了状态记录，每次执行之前都会通过状态属性判断。只有touchstart、touchmove事件对应的状态属性已触发并且touchend对应的状态属性未触发时才执行swiper对象的滑动动画函数。如果touchend的状态没有成功记录就会重复触发swiper对象的动画切换事件。在“info.js”中采取了将touchend设置成获取手势滑动方向。即获取了手势后swiper就自动结束，在获取到手势的同时在getDirection也同时进行了页面的滑动，从而避免刷屏。除此之外，也可以在swiper对象的外层设置触摸监听，并限定监听函数的无限次执行监听事件对应的监听逻辑函数 ，使动画不会无限次执行。在之前e.currentTarget注册的监听事件组件中进行修改即可。 巍然不动可能是swiper组件内部问题：当无法响应用户快速翻动动作时，当前页变量current无法变更为正确页码索引，而是被置为0。 可以通过下面方法解决： 1234567891011swiperchange: function (event) &#123; if (event.detail.source == &quot;touch&quot;) &#123; //防止swiper控件卡死 if (this.data.current == 0 &amp;&amp; this.data.preIndex&gt;1 ) &#123;//卡死时，重置current为正确索引 this.setData(&#123; current: this.data.preIndex &#125;); &#125; else &#123;//正常轮转时，记录正确页码索引 this.setData(&#123; preIndex: this.data.current &#125;); &#125; &#125; &#125; 2.后端2.1.如何获取 OpenIdOpenid 是表示用户在你的当前应用中的唯一标识,比如小程序，微信公众号等，这些都算是一个应用，如果同时拥有多个应用，同一个用户的openId可能并不相同。 第一步：获取code 调用wx.login(OBJECT) 获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。 注：调用Login会引起登录态的刷新，之前的session_key可能会失效！所以没事不要随便清除缓存，不然在微信开发者平台，你的数据被清除了。但是在phpmyadmin上仍然有你的数据，导致你无法登录你的小程序。形成了题库进得去，但是个人界面一片空白的情况。（这时候建议把phpmyadmin全清空，重做一次。） 第二步：根据code获取openid和session_key 这是一个 HTTPS 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。 注：此时如果未勾选项目中的“开发环境不效验请求域名、TLS版本以及HTTPS证书”则会出现报错 。 如果在配置服务器域名中填写了“api.weixin.qq.com”会出现上述错误提示。出于安全考虑，为避免开发者将AppSecret放置在小程序的前端代码内，平台禁止设置此域名。 小程序的开发者密码（AppSecret）是一个非常重要的字段，使用该密码可以调用小程序的所有后台接口。请不要将该字段放置在微信小程序的前端代码中，因为微信手机客户端容易被反编译并轻松获得Appsecret，造成重大的安全威胁。开发者应将Appsecret保存到后台服务器中，通过服务器使用Appsecert获取Accesstoken。微信公众平台小程序后台的服务器地址设置也将禁止将“api.weixin.qq.com”域名的配置，所有对于“api.weixin.qq.com”域名下的接口请求请全部通过后台服务器发起，请勿直接通过小程序的前端代码发起。 解决：所以解决办法就是把code传给后台，让后台去请求微信的官方接口获得openId和session-key。 第三步：检测用户登录状态是否有效 通过wx.checkSession(OBJECT)获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用wx.checkSession接口检测当前用户登录态是否有效。登录态过期后开发者可以再调用wx.login获取新的用户登录态。 2.2.关于申请课程号和上传自己的Appid虽然我向老师反馈过问题，不过还是做个记录 12https://index.php/Api/User/createCourse?appid=自己的appid&amp;courseName=课程名称&amp;questionSet=数据库中存储的题目集id&amp;creater=教师https://localhost/1/index.php/Page/Index/register 是无法成功申请和上传的。大家可以查看一下自己的url,会发现自己的本地域名为127.0.0.1.由于目前大部分的电脑都有安装IPV6,在IPV6里127.0.0.1 = ::1，而“::1”在 Windows 中，这个域名是预定义的,分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。因此由于域名冲突，导致无法成功申请。 解决：采用IPV4，即像现在ppt中写的用“http://”；或者是自己申请一个域名（如果打算上传这个小程序的话） 2.3. 后端任务：提要钩玄其实没打算加这块，因为感觉老师的ppt讲得很详细了，不过有人问我，那还是稍微写一些。 （你们以为我会直接放答案吗？不存在的。） 大部分任务在\www\1\Application\Api\Controller\UserController.class.php 任务三：还需获取哪五个数据？ 我们之前在前端注册时填写的五个数据（姓名，电话，学校，学号，入学年份）。举个例子：$openid = I(‘openid’); 任务四：根据上面对student表添加数据，完成对weixin表添加数据 已经有模板了，不知道添加哪些数据的，去phpmyadmin里翻weixin表。 任务五：完成类型为学生的查询,将数据封装在$user_info数组中 这个任务在\www\1\Application\Api\Logic\MyLogic.class.php 任务五也有模板，抄就完事了。 任务六： 跟任务三，大同小异，不再赘述。 “$info=”不知道怎么写的，看任务七，有模板的。（$details=） 任务七：添加数据到表 仿造上面的模板。 如何更新数据在任务六做过了，翻翻之前是怎么写的。 任务八、任务九、任务十： 看看ppt上是怎么写。 总结这次实训看似很难，又是小程序开发，又是php。第一次上实训直播的时候我是准备摸鱼的。后来专门抽出了两三天的时候，打算水实训。仔细学习了一下，发现所有的难点都有讲解。于是开始好好做。不过由于不是真·从0开始，所以我目前遇到的问题比较少。等以后有机会再做小程序的话，我再继续更新这个系列，不过这就是后话了。 螣蛇无足而飞，鼯鼠五技而穷。接下来我将会不断更新我在复习C/C++时候的学习心得。希望大家能给我的公众号点个关注，谢谢。（我也会在我的个人博客同步更新，不过最近七牛云开始收钱了，所以博客里的文章将会和公众号有些初入。）]]></content>
  </entry>
  <entry>
    <title><![CDATA[插入排序总结]]></title>
    <url>%2F2019%2F09%2F11%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[插入排序基本思想每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 直接插入排序直接插入排序的基本思想是：当插入第i(i &gt;= 1)个元素时，前面的R[0]，R[1]，……，R[i-1]已经排好序。这时，用R[i]与R[i-1]，R[i-2]，…R[0]的元素大小进行比较，找到插入位置即将R[i]插入，原来位置上的元素向后顺移。 12345678910111213void InsertSort(T* array, int n) &#123; //array待排序数组,n:数组元素数量 int i, j; //循环变量 T temp; //存储待排序元素 for (i = 1; i &lt; n; i++) &#123; j = i; temp = array[i]; //待排序元素赋值给临时变量 while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) &#123; //当未达到数组的第一个元素或者待插入元素小于当前元素 array[j] = array[j - 1]; //就将该元素后移 j--; //下标减一，继续比较 &#125; array[j] = temp; //插入位置已经找到，插入 &#125; &#125; 折半插入排序折半插入排序的基本思想是：遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则lowm-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1~high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。 第一步： 第二步： 第三步： 第四步： 第五步： 第六步： 第七步： 12345678910111213141516171819202122void BinInsertSort(T* array,int n)&#123; int i,j,low,high,mid T temp; for(i=1li&lt;n;i++)&#123; if(array[i]&lt;array[i-1])&#123; //反序 temp=array[i]; low=0; high=i-1; while(low&lt;=high)&#123; //在array[low…high]中查找插入位置 mid=(low+high)/2; //折中 if(temp&lt;array[mid]) high=mid-1; //插入点在左半边 else low=mid+1; //插入点在右半边 &#125; for(j=i-1;j&gt;=high+1;j--) //插入后元素后移 array[j+1]=array[j]; array[high+1]=temp; //插入temp &#125; &#125;&#125; 希尔排序]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奶妈级攻略：Markdown语法]]></title>
    <url>%2F2019%2F08%2F24%2F%E5%A5%B6%E5%A6%88%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9AMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 上一期攻略教会大家如何创建一个Hexo博客。由于Hexo的文档采用Markdown格式，和我们平时常用的Word截然不同。因此今天教大家Markdown。 一.前期准备 新建一个文档 还记得上期攻略如何教大家创建文档的么？例如我现在要创建一个叫做“Test”的文档： 打开控制台，输入：cd blog 输入hexo n &quot;Test&quot; ,创建文档 下载Typora Typora是我比较喜欢的一个Markdown编辑器，而且比较好用。 二.基本语法 2.1.字体设置斜体、粗体、删除线 功能 输入内容 显示效果 斜体 *文字* 文字 粗体 **文字** 文字 倾斜粗体 ***文字*** 文字 删除线 ~~ 文字 ~~ 文字 2.2.分级标题 标题 创建几级标题就在标题前加几个#。最多只有六级标题，例如：创建五级标题 #####五级标题 五级标题 列表 无序列表 在列表前加*，例如： 无序列表 有序列表 在列表前加数字. ，例如： 有序列表 任务列表 在列表前加- [ ] ，例如： 任务列表 2.3. 分界线输入 “---” 或者 “***” 或者 “___” ，然后回车。 2.4.代码块在两个`之间输入想要的内容,例如： abc 多行代码块：输入三个连续的` 1abc 2.5.链接在&lt;&gt;之间输入网址，例如： https://orchid-02.cn 2.6.引用键入 ” &gt; “ 输入你想要的内容，例如： 引用 嵌套引用，键入多个 “ &gt; “ ，例如： 引用 三.进阶语法 3.1. 字体、字号与颜色Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能。所以我们需要用内嵌HTML的方法来实现: &lt;font color=red size=6 face=&quot;STCAIYUN&quot;&gt;华文彩云&lt;/font&gt; 实现效果：华文彩云 color:颜色。输入已知的颜色名称 size:字号。输入数字。一般默认值为3 face：字体。输入想要的字体。 四.快捷键 功能 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y 参考链接 https://blog.csdn.net/u014061630/article/details/81359144]]></content>
      <tags>
        <tag>奶妈级攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奶妈级攻略：Hexo的创建]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%A5%B6%E5%A6%88%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9AHexo%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言 很早就想做一个属于自己的个人博客。打算做成像高中的学习笔记一样的，记录学习上的各种心得，当然如果能帮到别人更是再好不过。以前也试过用其他博客平台搭建博客，但是效果不是很好，最终不了了之。直到一天在B站刷羊哥的视频，看到“如何用HEXO搭建个人博客”，这就是我想要的博客。视频连接在文末，此贴完。（笑）不过视频长达半小时，而且羊哥用的是mac，与windows不太一样，我就整理了一份图文版，希望可以帮到其他和我有一样需求的小伙伴。 关于Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备 下载node.js (下载地址：https://nodejs.org/en/download/ ) Hexo是基于node.js 的。下载成功后进入电脑终端(控制台)（win + r ，输入：cmd） 输入node -v ，显示当前 Node.js 版本号，表示安装成功。 输入*npm -v *，显示当前 npm 版本号，表示安装成功。 但是npm是 国外的，下载速度不稳定，所以最好安装国内的镜像源： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 输入*cnpm -v *，显示当前 cnpm 版本号，表示安装成功。 拥有一个github账号（地址：https://github.com/ ） 作为一只程序猿没有自己的github账号说得过去吗（笑）Github作为世界上最大的代码存放网站的开源社区,用来存储代码比较方便。 创建个人仓库 点击 GitHub 中的 New reository 创建新仓库，仓库名应该为：username.github.io，这个 username 使用你的 GitHub 帐号名称代替，这是固定写法，比如我的仓库名为：Orchid-02.github.io （题外话：如何用github保护自己的代码） 假如你是一位大佬（如果是大佬肯定已经会了），平时遇到有同学想抄你的代码作业怎么办？不让抄吧，伤了和气；直接给吧，怕鸩占鹊巢。有一个很简单的方法：把代码放在github上，同时贴一个gpl协议。然后有人想抄代码时，告诉他地址。有gpl协议的代码完全开源，同时也受到版权保护。 安装Hexo Hexo 就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为 Blog，Hexo 框架与以后你自己发布的网页都在这个文件夹中。 打开控制台，输入：cnpm install -g hexo -cli ,就开始下载Hexo 输入*hexo -v *，显示当前 Hexo 版本号，表示安装成功。 输入mkdir Blog ,创建文件夹。(mkdir用以在当前目录下创建一个子目录) 输入hexo init ,初始化博客 输入dir ,查看生成的文件（可以有但没必要） Hexo常用命令 npm update hexo -g #升级 hexo init #初始化博客 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 将Hexo部署到GitHub上 下载Git：cnpm install --save hexo-deployer-git 打开Blog文件夹，找到_config.yml ,打开并拉至底部 按图片修改，repo填入的是你之前在Github上创建仓库的完整路径，最后的“.git”不能省略 修改完后，素质三连：hexo clean、hexo g、hexo d 在hexo g后也可以输入hexo s 。在浏览器的地址栏里输入localhost:4000查看预览 完成后，在浏览器的地址栏输入你放置个人网站的仓库路径，就可以访问你的博客 划红框的是Hexo的主题，当然这是下一篇攻略的内容，如何打造一个花里胡哨的博客。这里先放两张我的博客截图： 设置Github秘钥 刚刚已经下载好了Git，然后需要将你的Git和github账号绑定。 鼠标右键打开Git Bash 设置 user.name 和 user.email 配置信息: 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh秘钥： 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 直接三个回车，默认不需要设置密码 然后找到生成的.ssh的文件夹的id_rsa.pub秘钥，复制全部内容 打开：https://github.com/settings/keys ，新建new SSH Key TITLE是标题，可以随意填，将刚刚复制的内容黏贴进去，点击Add SSH Key 在Git Bash中检测Github秘钥设置是否成功：输入ssh git@github.com 出现上图所示即绑定成功。 这里之所以设置 GitHub 密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在 GitHub上，私钥放置在自己的电脑里。GitHub 要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了 ssh，当你推送的时候，git 就会匹配你的私钥跟 GitHub 上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 绑定域名 虽然我们的的博客已经可以在互联网上被访问，但网址是 GitHub 提供的二级域名username.github.io, 不方便记忆。此时我们就需要绑定自己的域名。虽然我的博客不作商业用途，但是如果你打算靠博客赚点外快的话，不仅需要绑定域名，还要域名备案。 购买域名： 虽然不少人认为阿里云比较好，不过我使用的是腾讯云。至于购买完域名后的一系列操作，腾讯云上都有教，这里不再赘述。 修改Github设定 虽然你买了域名，但是Github不知道呀，因此我们得让Github知道你的博客地址改了（本质还是存储在你的二级域名上，但是会直接跳转到你购买的一级域名上） 在 {your_hexo_folder}/source / 下，创建一个名字为 CNAME 的文件，内容即是你的个人域名： 1Orchid-02.cn 然后同样素质三连。 再次打开浏览器，输入你的域名，你就可以通过自己的域名访问Github上自己的博客了。 参考链接 https://www.bilibili.com/video/av44544186 https://blog.diqigan.cn/posts/build-your-blog-with-github-and-hexo.html]]></content>
      <tags>
        <tag>奶妈级攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA之异常]]></title>
    <url>%2F2019%2F08%2F21%2FJAVA%E4%B9%8B%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1.异常简介1.1.什么是异常Java异常是一个描述在代码段中发生的出错的情况，Java异常可能是由Java运行时系统产生，或者是由你自己写的代码产生。Java“异常处理”机制是Java提供的一种识别及响应错误的一致性机制。 Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答3个问题：异常类型回答了 “什么” 被抛出，异常堆栈跟踪回答了 “在哪“ 抛出，异常信息回答了 “为什么“ 会抛出。 1.2.JAVA异常类层次结构 Throwable 在JAVA中所有的异常都是Throwable类派生出来的类的实例。Throwable类有两个子类：Error和Exception Error Error 类层次结构用于描述 Java 运行时系统的内部错误和资源耗尽错误，这类错误是程序无法处理的严重问题，一旦出现，除了通告给用户并尽可能安全终止程序外，别无他法。 例如： JVM 内存资源耗尽时出现的 OutOfMemoryError 栈溢出时出现的 StackOverFlowError 类定义错误 NoClassDefFoundError Exception 相较于 Error，Exception 类层次结构所描述的异常更需要 Java 程序设计者关注，因为它是程序本身可以处理的。Exception 类的“下一代”分化为两个分支：RuntimeException + 其它异常。 划分两个分支的原则为： 由程序错误导致的异常属于 RuntimeException。 而程序本身没有问题，但由于 I/O 错误之类问题导致的异常属于其它异常。 关于异常和错误的区别：通俗地讲，异常是程序本身可以处理的，而错误则是无法处理的。 Unchecked 不可检查异常（Unchecked Exception）是 Java 编译器不强制要求处置的异常。Java 语言规范将 Error 类和 RuntimeException 及其子类归类为不可检查异常。 为什么编译器不强制要求处置呢？不是因为这类异常简单，危害性小，而是因为这类异常是应该尽力避免出现的，而不是出现后再去补救。以 RuntimeException 类及其子类为例： NullPointerException（空指针异常） IndexOutOfBoundsException（下标越界异常） IllegalArgumentException（非法参数异常） 这些异常通常是由不合理的程序设计和不规范的编码引起的，工程师在设计、编写程序时应尽可能避免这类异常的发生，这是可以做到的。在 IT 圈内有个不成文的原则：如果出现 RuntimeException 及其子类异常，那么可认为是程序员的错误。 Check 可检查异常也称为已检查异常（Checked Exception），这类异常是编译器要求必须处置的异常。在工程实践中，程序难免出现异常，其中一些异常是可以预计和容忍的，比如： 读取文件的时候可能出现文件不存在的情况（FileNotFoundException），但是，并不希望因此就导致程序结束，那怎么办呢？ 通常采用捕获异常（try-catch）或者抛出异常（throws 抛出，由调用方处理）的方式来处理。 可检查异常虽然也是异常，但它具备一些重要特征：可预计、可容忍、可检查、可处理。因此，一旦发生这类异常，就必须采取某种方式进行处理。 Java 语言规范将派生于 Error 类或 RuntimeException 类之外的所有异常都归类为可检查异常，Java 编译器会检查它，如果不做处理，无法通过编译。 对于可以恢复的条件使用Check，对于程序使用错误使用RuntimeException 1.3.异常处理机制在 Java 应用程序中，异常处理机制有：抛出异常、捕捉异常。 Java异常机制用到的几个关键字：try、catch、finally、throw、throws. • try *：用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 • *catch : 用于捕获异常。catch用来捕获try语句块中发生的异常。 • finally : finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 • throw : 用于抛出异常。 • throws : 用在方法签名中，用于声明该方法可能抛出的异常。 抛出异常 这里的“抛出异常”是指主动抛出异常。在设计、编写程序时，我们可以预料到一些可能出现的异常，如 FileNotFoundException，有时候我们并不希望在当前方法中对其进行捕获处理，怎么办呢？抛出去，让调用方去处理，通过 throw 关键字即可完成，如： throw new FileNotFoundException() 关于抛出异常，还有一个点需要补充，那就是声明可检查异常。在设计程序的时候，如果一个方法明确可能发生某些可检查异常，那么，可以在方法的定义中带上这些异常，如此，这个方法的调用方法就必须对这些可检查异常进行处理。 声明异常 根据 Java 规范，如果一个 Java 方法要抛出异常，那么需要在这个方法后面用 throws关键字明确定义可以抛出的异常类型。倘若没有定义，就默认该方法不抛出任何异常。这样的规范决定了 Java 语法必须强行对异常进行try-catch。如下的方法签名： public void foo() throws FileNotFoundException { ... } 暗含了两方面的意思： 第一，该方法要抛出 FileNotFoundException 类型的异常； 第二，除了 FileNotFoundException 外不能（根据规范）抛出其它的异常。 那么，如何保证没有除 FileNotFoundException 之外的任何异常被抛出呢？很显然，方式有： 通过合理的设计和编码避免出现其它异常； 如果其它异常不可完全避免（如方法内调用的其它方法明确可能出现异常），就需要 try-catch 其它的异常。 简而言之，一般情况下，方法不抛出哪些异常就要在方法内部 try-catch 这些异常。 例如： 12345678910111213141516171819202122232425class MyException extends Exception &#123; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; test(); &#125; catch (MyException e) &#123; System.out.println(&quot;Catch My Exception&quot;); e.printStackTrace(); &#125; &#125; public static void test() throws MyException&#123; try &#123; int i = 10/0; System.out.println(&quot;i=&quot;+i); &#125; catch (ArithmeticException e) &#123; throw new MyException(&quot;This is MyException&quot;); &#125; &#125;&#125; 运行结果： 1234Catch My ExceptionMyException: This is MyException at Demo3.test(Demo3.java:24) at Demo3.main(Demo3.java:13) MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。 捕获异常 抛出异常十分容易，抛出去便不用再理睬，但是，在一些场景下，必须捕获异常并进行相应的处理。如果某个异常发生后没有在任何地方被捕获，那么，程序将会终止。 在 Java 中，捕获异常涉及三个关键字：try、catch 和 finally： 1234567try &#123; 可能发生异常的代码块&#125; catch (某种类型的异常 e) &#123; 对于这种异常的处理代码块&#125; finally &#123; 处理未尽事宜的代码块：如资源回收等&#125; 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package Textpublic class TryCatchTest&#123; public static void main(String[] args)&#123; TryCatchTest tct = new TryCatchTest(); int result = tct.test(); System.out.println(&quot;test()方法执行完毕，返回值为：&quot; + result); int result2 = tct.test2(); System.out.println(&quot;test2()执行完毕&quot;)； &#125; /** *divider(除数) *result(结果) *try-catch捕获while循环 *每次循环，divider减一，result=result+100/divider *如果：捕获异常，打印输出“循环抛出异常了”，返回 result=-1 *否则：返回result */ public int test()&#123; int divider=10; int result=100; try&#123; while(divider&gt;-1)&#123; divider--; result=result+100/divider; &#125; return result; &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(&quot;循环抛出异常了&quot;); return -1; &#125; &#125; /** *divider(除数) *result(结果) *try-catch捕获while循环 *每次循环，divider减一，result=result+100/divider *如果：捕获异常，打印输出“循环抛出异常了”，返回 result=999 *否则：返回result *finally:打印输出：“执行finally：”，同时打印输出result */ public int test2()&#123; int divider=10; int result=100; try&#123; while(divider&gt;-1)&#123; divider--; result=result+100/divider; &#125; return result; &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(&quot;循环抛出异常了&quot;); return result=999; &#125;finally&#123; System.out.println(&quot;执行finally：&quot;); System.out.println(result); &#125; &#125;&#125; 在这段代码中，声明了我想要的异常监控包含在一个try块中，如果在try中发生异常，它会被抛出。在下面我可以用catch关键字来捕获try块中产生的异常并自己可以处理这个异常。 系统产生的异常会在Java运行时系统自动抛出。但是也可以手动抛出一个异常，让上一层代码去捕获处理，用关键字throw。但是需要在方法后面通过throws关键字定义可能抛出的异常。 运行结果： 123456循环抛出异常了test()执行完毕，返回值为：-1循环抛出异常了执行finally：999test2()执行完毕 finally块的代码不管try块中会不会抛出异常，都会执行finally块中的代码，而这里的代码一般用作关闭数据库连接或者关闭IO流对象以便不浪费资源。 自定义异常类 例如： 12345678910111213141516171819202122232425262728293031public class Test&#123; //计算a/b public int f(int a,int b) throws MyException&#123; //如果除数等于0，那么就抛出一个MyException异常 if(b==0)&#123; throw new MyException(&quot;抛出了这个异常:除数不能等于0&quot;); &#125; return a/b; &#125; public static void main(String[] args) &#123; Test t=new Test(); try &#123; t.f(10, 0); //在这里捕获f()方法中抛出的MyException异常 &#125; catch (MyException e) &#123; e.print(); &#125; &#125; &#125;//自定义的异常需要继承Exception或者Throwable类class MyException extends Exception&#123; private String str; public MyException(String str) &#123; this.str=str; &#125; public void print()&#123; System.out.println(str); &#125;&#125; 定义自己的异常类也需要继承Exception类 运行结果： 1抛出了这个异常:除数不能等于0 2.异常处理机制的原理Java 虚拟机并不绑定任何编程语言（包括 Java 语言），而是与“Class 文件”这种特定的二进制格式文件强关联。Java 编译器可以将 Java 代码编译成存储字节码的 Class 文件，这种 Class 文件包含了 Java 虚拟机指令集、符号表等信息。 2.1.Class 文件的格式Class 文件是一组以 8 位字节为基础单位的二进制流，程序编译后的数据按照严格的顺序紧密排列，其间没有任何分隔符。从数据结构来看，Class 文件采用了一种类似 C 语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。其中，表主要有方法表、字段表和属性表，为便于读者理解后文的内容，在此着重介绍一下属性表。 属性表（attribute_info） 属性表可以存在于 Class 文件、字段表、方法表中（数据结构是可以嵌套的），用于描述某些场景的专有信息。属性表中有个 Code 属性，该属性在方法表中使用，Java 程序方法体中的代码被编译成的字节码指令存储在 Code 属性中。 异常表（exception_table） 异常表是存储在 Code 属性表中的一个结构，但是，这个结构并不是必须存在的，很好理解，如果方法中根本就没有异常相关的代码，编译结果中自然也不会有异常表。 2.2.异常表异常表的结构如下表所示。它包含 4 个字段，含义为： 如果当字节码在第 start_pc 行到 end_pc 行之间（不包含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type 为指向一个 CONSTANT_Class_info 型常量的索引），则跳转到第 handler_pc 行执行。如果 catch_type 的值为 0，则表示任意异常情况都需要转到 handler_pc 处进行处理。 类型 名称 数量 u2 start_pc 1 u2 end_pc 1 u2 handler_pc 1 u2 catch_type 1 注：u2是一种数据类型，表示2个字节的无符号数。 异常表是 Java 代码的一部分，编译器使用异常表而不是简单的跳转指令来实现 Java 异常及 finally 处理机制。 2.3.异常处理得基本原理具备处理异常能力的 Java 类编译后，都会跟随一个异常表，如果发生异常，首先在异常表中查找对应的行（即代码中相应的 try{}catch(){} 代码块），如果找到，则跳转到异常处理代码执行，如果没有找到，则返回（如果有 finally，须在执行 finally 之后），并复制异常给父调用者，接着查询父调用的异常表，以此类推，直至异常被处理或者因没有处理而导致程序终止。 3. Java 异常处理的基本原则在异常处理的整个过程中，需要初始化新的异常对象，从调用栈返回，而且还需要沿着方法的调用链来传播异常以便找到它的异常处理器，因此，相较于普通代码异常处理通常需要消耗更多的时间和资源。为了保证代码的质量，有一些原则需要遵守。 1. 细化异常的类型，避免过度泛化 尽量避免将异常统一写成 Excetpion。原因有二： 针对 try 块中抛出的每种 Exception，很可能需要不同的处理和恢复措施，如果统一为 Excetpion，则只有一个 catch 块，分别处理就不能实现。 try 块中有可能抛出 RuntimeException，如果代码中捕获了所有可能抛出的 RuntimeException 而没有作任何处理，则会掩盖编程错误，导致程序难以调试。 try { … } catch (Exception e) { // 过分泛华的异常 … } 2.多个异常的处理规则 子类异常的处理块必须在父类异常处理块的前面，否则会发生编译错误。因此，在实践中，越特殊的异常越在前面处理，越普遍的异常越在后面处理。换句话说，能处理就尽早处理，不能处理的就抛出去。当然，对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能地控制异常发生的可能。 3. 避免过大的 try 块 避免将不会出现异常的代码放到 try 块里面。举个例子：循环的场景，注意 try 代码块的范围。 1234567891011121314151617// 不恰当的方式try &#123; while(rs.hasNext()) &#123; foo(rs.next()); &#125;&#125; catch (SomeException se) &#123; ...&#125;// 较为恰当的方式while(rs.hasNext()) &#123; try &#123; foo(rs.next()); &#125; catch (SomeException se) &#123; ... &#125;&#125; 4. 延迟捕获 延迟捕获：对异常的捕获和处理需要根据当前代码的能力来决定，如果当前方法内无法对异常做有效处理，即使出现了检查异常也应该考虑将异常抛出给调用者做处理，如果调用者也无法处理，理论上它也应该继续上抛，这样异常最终会在一个适当的位置被 catch 下来，而比起异常出现的位置，异常的捕获和处理是延迟了很多，但同时也避免了不恰当的处理。 5. 对于可检查异常的处理 对于可检查异常，如果不能行之有效地处理，还不如转换为 RuntimeException 抛出。如此，可以让上层的代码有选择的余地。 6.异常处理框架 在实际应用场景中，对于一个应用系统来说，应该要有自己的一套异常处理框架，如此，当异常发生时，就能得到统一的处理风格，将优雅的异常信息反馈给用户。举个例子，如微信、淘宝、支付宝之类的应用，后端涉及的组件非常多，各个组件可能都有自己一套异常处理机制，如果在对接用户（C 端）的口子上不用统一的框架进行处理，那么呈现给用户的异常信息将会失控。 7. 不要忽略异常 对于捕获的异常，可以只打个日志，但是尽量避免什么都不做。 123try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#125; catch (ClassNotFoundException ex) &#123;&#125; //忽略的异常，挖坑 8. 避免异常转化过程丢失信息 有时候，我们需要将捕获的异常进行转化，但是，在此过程中应尽量避免丢失原始信息，如下反例： 12345678910111213// 抛出异常try &#123; ...&#125; catch (IOException ioe) &#123; throw new Exception(ioe); // 泛化了异常， 外层调用丢失了异常类型的优势&#125;// 自定义异常try &#123; ...&#125; catch (SqlException sqle) &#123; throw new MyOwnException(); // 定义了新的异常，但是丢了原始异常信息&#125; 9. 生产代码避免 printStackTrace() 12345678910111213141516171819202122232425// 不好的方式try &#123; ...&#125; catch (IOException e) &#123; e.printStackTrace();&#125;try &#123; ...&#125; catch (IOException e) &#123; logger.error(&quot;message here&quot; + e);&#125;try &#123;&#125; catch (IOException e) &#123; logger.error(&quot;message here&quot; + e.getMessage());&#125;// 比较好的方式try &#123; ...&#125; catch (IOException e) &#123; logger.error(&quot;message here&quot;, e);&#125; 参考链接 https://blog.csdn.net/qq_44057443/article/details/89606732 https://blog.csdn.net/xkfanhua/article/details/80570885 https://gitchat.csdn.net/activity/5c867a1d0bda8f2bb35634b0]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA的输入与输出]]></title>
    <url>%2F2019%2F08%2F20%2FJAVA%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[一.输入与输出应用程序（Java Application）的输入输出可以是文本界面，也可以是图形界面小程序（Java Applet）则*只能是图形界面 *每种界面都可以有输入和输出 二.文本界面的输入 文本界面输入使用Scanner类,Sanner类在java.util包中，所以使用Scanner类需要写 import java.util.Scanner 定义语句：Scanner scanner = new Scanner(System.in); Scanner类的方法有: nextInt(),用来得到一个整数； nextDouble(),用来得到一个实数； next(),用来得到一个字符串. nextline(),将输入的那一行数据作为结果返回 hasNextInt(),判断释放是否还有整数 hasNextDouble(),判断释放是否还有浮点数 hasNext(),判断输入中是否还有其他单词 Scanner in = new Scanner(Path.get(“myfile.txt”));从文件中读取 使用Scanner类进行键盘读入 定义语句：Scanner sc = new Scanner(System.in); 创建一个Scanner对象“sc”，System.in表示标准化输出，即键盘输出. int a = sc.nextInt(); //输入一个整数 double b = sc.nextDouble(); //输入一个浮点数 string c = sc.next(); //输入字符串 例： 12345678910package Orchid-02;import java.util.Scanner;public class Text&#123; public static void main(String args[])&#123; Scanner sc =new Scanner(System.in); int a=sc.nextInt();//输入一个整数 System.out.println(&quot;请输入一个整数&quot;); System.out.println(a); &#125;&#125; 使用Scanner类获取文件内容 例一：读取项目文档 1234567891011121314151617181920212223package Orchid-02;import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;public class Text&#123; public static void main(String[] args)&#123; Scanner sc; try &#123; //读取项目中的文档 sc = new Scanner(new File(&quot;ScannerTest.txt&quot;)); System.out.println(&quot;项目中的文本内容是：&quot;); //通过判断是否有下一行来输出文档内容 while (sc.hasNextLine()) &#123; System.out.println(sc.nextLine()); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 例二：读取本地文档 12345678910111213141516171819202122232425package Orchid-02; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.util.Scanner; public class Text&#123; public static void main(String[] args)&#123; FileInputStream fis; try &#123; //利用文件上传功能 fis = new FileInputStream(&quot;D:\\text\\ScannerTest.txt&quot;); //设置文件编码 Scanner sc = new Scanner(fis,&quot;UTF-8&quot;); System.out.println(&quot;本地文件内容：&quot;); //输出文件内容 while (sc.hasNextLine()) &#123; System.out.println(sc.nextLine()); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 三.文本界面的输出 文本界面输入输出：使用System.in及System.out. 包含在java.io包中 输出：System.out.print()及println(),printf(),write() print\println\printf,write的区别: print()将它的参数显示在命令窗口，并将输出光标定位在所显示的最后一个字符之后。 println()将它的参数显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。 printf()是格式化输出的形式。 write()常用来输出字节数组，但是write()在输出单个字节时，并不能立即显示出来，必须调用System.out.flush()回显。 关于System.in.read() 在JAVA程序中，使用System.in.read()方法从键盘读入一个字符时，必须引入“异常处理“机制。 引入异常处理机制的方法 a.直接在main方法后面用throws子句抛出IOException。即： 1public static void main(String[] args) throws java.io.IOException b.在程序第一行引入import java.io.*;加载语句，然后在main方法首部的末尾加上throws IOException，如： 123456import java.io.*;public class 类名 &#123; public static void main(String[] args) throws IOException&#123; 方法体 &#125;&#125; 四.强制类型转换 将string型转换为int型：Integer.parseInt(s); 将string型转换为double型：Double.parseDouble(s); 由于double型的范围比int型大，所以int转double不需要强制类型转换 将double型转换为int型： 取整 向上取整：Math.ceil(double a) 向下取整：Math.floor(double a) 四舍五入取整：Math.round(double a) 强制转换 1234double d = 5.6; int i = (int)d; System.out.println(&quot;i=：&quot;i); //输出为5 五.数组的输入与输出依旧调用Scanner类 数组初始化：数组类型[] 数组名 = new 数据类型[数组长度] 1int[] str = new int[105]; 在给数组命名的时候，一般在数组名后加一个 s 表示这是一个包含多个元素的数组（与单个变量区分）。 当数组采用动态初始化开辟空间之后，数组之中的每个元素都是该数据类型的默认值。 数据类型 默认初始化 byte,short,int,long 0 float,double 0.0 char 一个空字符，即’\u0000’ boolean（布尔型） false 引用数据类型 null,表示变量不引用任何对象 访问数组数据 ,使用数组下标访问 c=a[4]; 数组输入： 1234int a[]=new int[110]; for(int i=1;i&lt;=n;i++)&#123; a[i]=in.nextInt(); &#125; 数组输出： for循环： 123for(int i=0;i&lt;array.length;i++)&#123; System.out.println(a[i]); &#125; for each循环： 12for(int a:array) System.out.println(a); Array类toString方法： 调用Array.toString(a)，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分开 12int[] array = &#123;1,2,3,4,5&#125;; System.out.println(Arrays.toString(array)); ***tip:System.out.println(array);这样是不行的，这样打印是的是数组的首地址。*** 多维数组输出： JAVA实际上没有多维数组，只有一维数组，多维数组被认为是“数组的数组” for循环： 123456for(int i=0;i&lt;magicSquare.length;i++)&#123; for(int j=0;j&lt;magicSquare[i].length;j++)&#123; System.out.print(magicSquare[i][j]+&quot; &quot;); &#125; System.out.println(); &#125; for each循环： 123456for(int[] a:magicSquare)&#123; for(int b:a)&#123; System.out.print(b+&quot; &quot;); &#125; System.out.println(); &#125; Array类toString方法： 12for(int i=0;i&lt;magicSquare.length;i++) System.out.println(Arrays.toString(magicSquare[i])); 六.图形界面的输入与输出 Java Application（图形界面）的输入与输出首先需要创建自己的图形界面,创建Frame然后加入对象，添加对象的监听器，写函数具体处理事件 Applet（图形界面）输入与输出在init()中加入对象，加入监听器 同时作为Application和Applet的程序在main()中创建一个用户界面，并将这个Applet加入 七.常规输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package pers.frank.test;import java.util.Date;public class Test&#123; public static void main(String[] args) &#123; /*** 输出字符串 ***/ // %s表示输出字符串，也就是将后面的字符串替换模式中的%s System.out.printf(&quot;%s&quot;, new Integer(1212)); // %n表示换行 System.out.printf(&quot;%s%n&quot;, &quot;end line&quot;); // 还可以支持多个参数 System.out.printf(&quot;%s = %s%n&quot;, &quot;Name&quot;, &quot;Zhangsan&quot;); // %S将字符串以大写形式输出 System.out.printf(&quot;%S = %s%n&quot;, &quot;Name&quot;, &quot;Zhangsan&quot;); // 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串 System.out.printf(&quot;%1$s = %3$s %2$s%n&quot;, &quot;Name&quot;, &quot;san&quot;, &quot;Zhang&quot;); /*** 输出boolean类型 ***/ System.out.printf(&quot;true = %b; false = &quot;, true); System.out.printf(&quot;%b%n&quot;, false); /*** 输出整数类型***/ Integer iObj = 342; // %d表示将整数格式化为10进制整数 System.out.printf(&quot;%d; %d; %d%n&quot;, -500, 2343L, iObj); // %o表示将整数格式化为8进制整数 System.out.printf(&quot;%o; %o; %o%n&quot;, -500, 2343L, iObj); // %x表示将整数格式化为16进制整数 System.out.printf(&quot;%x; %x; %x%n&quot;, -500, 2343L, iObj); // %X表示将整数格式化为16进制整数，并且字母变成大写形式 System.out.printf(&quot;%X; %X; %X%n&quot;, -500, 2343L, iObj); /*** 输出浮点类型***/ Double dObj = 45.6d; // %e表示以科学技术法输出浮点数 System.out.printf(&quot;%e; %e; %e%n&quot;, -756.403f, 7464.232641d, dObj); // %E表示以科学技术法输出浮点数，并且为大写形式 System.out.printf(&quot;%E; %E; %E%n&quot;, -756.403f, 7464.232641d, dObj); // %f表示以十进制格式化输出浮点数 System.out.printf(&quot;%f; %f; %f%n&quot;, -756.403f, 7464.232641d, dObj); // 还可以限制小数点后的位数 System.out.printf(&quot;%.1f; %.3f; %f%n&quot;, -756.403f, 7464.232641d, dObj); /*** 输出日期类型***/ // %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式 Date date = new Date(); long dataL = date.getTime(); // 格式化年月日 // %t之后用y表示输出日期的年份（2位数的年，如99） // %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号 System.out.printf(&quot;%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n&quot;, date, dataL); // %t之后用Y表示输出日期的年份（4位数的年）， // %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称 System.out.printf(&quot;%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n&quot;, date, dataL); // 以下是常见的日期组合 // %t之后用D表示以 &quot;%tm/%td/%ty&quot;格式化日期 System.out.printf(&quot;%1$tD%n&quot;, date); //%t之后用F表示以&quot;%tY-%tm-%td&quot;格式化日期 System.out.printf(&quot;%1$tF%n&quot;, date); /*** 输出时间类型***/ // 输出时分秒 // %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制）， // %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒 System.out.printf(&quot;%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n&quot;, date, dataL); // %t之后用L表示输出时间的秒中的毫秒 System.out.printf(&quot;%1$tH:%1$tM:%1$tS %1$tL%n&quot;, date); // %t之后p表示输出时间的上午或下午信息 System.out.printf(&quot;%1$tH:%1$tM:%1$tS %1$tL %1$tp%n&quot;, date); // 以下是常见的时间组合 // %t之后用R表示以&quot;%tH:%tM&quot;格式化时间 System.out.printf(&quot;%1$tR%n&quot;, date); // %t之后用T表示以&quot;%tH:%tM:%tS&quot;格式化时间 System.out.printf(&quot;%1$tT%n&quot;, date); // %t之后用r表示以&quot;%tI:%tM:%tS %Tp&quot;格式化时间 System.out.printf(&quot;%1$tr%n&quot;, date); /*** 输出星期***/ // %t之后用A表示得到星期几的全称 System.out.printf(&quot;%1$tF %1$tA%n&quot;, date); // %t之后用a表示得到星期几的简称 System.out.printf(&quot;%1$tF %1$ta%n&quot;, date); // 输出时间日期的完整信息 System.out.printf(&quot;%1$tc%n&quot;, date); &#125;&#125; 参考链接 https://blog.csdn.net/a970973835/article/details/47010789 https://blog.csdn.net/tzllxya/article/details/90485743 https://blog.csdn.net/weixin_43846139/article/details/99637058]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客创建感想]]></title>
    <url>%2F2019%2F07%2F20%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[佛系学生狗，随缘更新 不定期投喂日常学习与工作的心得 小生才疏学浅，若有谬误，还望路过的大神们，不吝赐教 可能明后天会发如何创建个人博客的文章（虽然网上搜就有） 原本早上十一点就做完了，想着要出一期教程就推翻重做。结果成了噩梦的开始。 电脑突然自动重启，突然死机，突然断网……估计大部分坏事都被我碰上了。还有自己手贱试图做得好看点，奈何木得技术，各种问题不断。导致这个博客我应该是反反复复做了七八遍。 等我下学期有钱买域名了，再来装修一番。或者租个服务器，做个小论坛玩玩也不错。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
